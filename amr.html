<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMR Edge Device Simulation</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        
        // Lucide React icons as simple SVG components
        const Play = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polygon points="5 3 19 12 5 21 5 3"></polygon>
            </svg>
        );
        
        const Pause = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <rect x="6" y="4" width="4" height="16"></rect>
                <rect x="14" y="4" width="4" height="16"></rect>
            </svg>
        );
        
        const RotateCcw = ({ size = 20 }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <polyline points="1 4 1 10 7 10"></polyline>
                <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
            </svg>
        );
        
        const Activity = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}>
                <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
            </svg>
        );
        
        const Camera = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}>
                <path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path>
                <circle cx="12" cy="13" r="4"></circle>
            </svg>
        );
        
        const Compass = ({ size = 24, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" className={className}>
                <circle cx="12" cy="12" r="10"></circle>
                <polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>
            </svg>
        );

        const AMRSimulation = () => {
          const [isRunning, setIsRunning] = useState(false);
          const [currentStep, setCurrentStep] = useState(0);
          const [sensorData, setSensorData] = useState({
            imu: { accelX: 0, accelY: 0, gyroZ: 0 },
            camera: { obstacleDetected: false, distance: 0 },
            position: { x: 50, y: 50, angle: 0 }
          });
          const [processedData, setProcessedData] = useState(null);
          const [agentThinking, setAgentThinking] = useState('');
          const [decision, setDecision] = useState('');
          const [logs, setLogs] = useState([]);
          const [apiKey, setApiKey] = useState('');
          const [showApiInput, setShowApiInput] = useState(true);
          const intervalRef = useRef(null);
          const apiKeyRef = useRef('');

          const steps = [
            'Sensor Data Input',
            'Preprocessing & Fusion',
            'Context Engineering',
            'Agent Reasoning',
            'Decision Output',
            'Monitoring & Logging'
          ];

          const addLog = (message, type = 'info') => {
            const colors = {
              info: 'text-slate-300',
              success: 'text-green-400',
              warning: 'text-yellow-400',
              error: 'text-red-400'
            };
            setLogs(prev => [...prev.slice(-9), { 
              time: new Date().toLocaleTimeString(), 
              message, 
              type, 
              color: colors[type] || colors.info 
            }]);
          };

          const simulateSensorData = () => {
            const newData = {
              imu: {
                accelX: (Math.random() - 0.5) * 2,
                accelY: (Math.random() - 0.5) * 2,
                gyroZ: (Math.random() - 0.5) * 10
              },
              camera: {
                obstacleDetected: Math.random() > 0.7,
                distance: Math.random() * 100
              },
              position: {
                x: sensorData.position.x + (Math.random() - 0.5) * 5,
                y: sensorData.position.y + (Math.random() - 0.5) * 5,
                angle: sensorData.position.angle + (Math.random() - 0.5) * 15
              }
            };
            setSensorData(newData);
            addLog('Sensor data collected from IMU and Camera', 'success');
            return newData;
          };

          const preprocessData = (data) => {
            const filtered = {
              velocity: Math.sqrt(data.imu.accelX ** 2 + data.imu.accelY ** 2),
              rotation: data.imu.gyroZ,
              obstacleDistance: data.camera.obstacleDetected ? data.camera.distance : null,
              normalizedPosition: {
                x: Math.max(0, Math.min(100, data.position.x)),
                y: Math.max(0, Math.min(100, data.position.y)),
                angle: data.position.angle % 360
              }
            };
            setProcessedData(filtered);
            addLog('Data preprocessed and fused', 'success');
            return filtered;
          };

          const engineerContext = (processed) => {
            const context = `
Current State:
- Velocity: ${processed.velocity.toFixed(2)} m/s
- Rotation: ${processed.rotation.toFixed(2)} deg/s
- Position: (${processed.normalizedPosition.x.toFixed(1)}, ${processed.normalizedPosition.y.toFixed(1)})
- Heading: ${processed.normalizedPosition.angle.toFixed(1)}¬∞
${processed.obstacleDistance !== null ? `- Obstacle detected at ${processed.obstacleDistance.toFixed(1)}m` : '- No obstacles detected'}

Task: Navigate safely while avoiding obstacles and maintaining stable movement.
            `;
            addLog('Context engineered for LLM agent', 'success');
            return context;
          };

          const agentReasoning = async (context) => {
            setAgentThinking('Analyzing sensor data with Google Gemini...');
            addLog('Calling Google Gemini API...', 'info');
            
            try {
              const apiKey = apiKeyRef.current;
              
              if (!apiKey) {
                throw new Error('API key not configured');
              }

              const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-pro:generateContent?key=${apiKey}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  contents: [{
                    parts: [{
                      text: `You are an autonomous mobile robot (AMR) decision-making agent. Based on the following sensor data and context, provide your reasoning and decide on ONE action.

${context}

Available Actions:
- TURN_LEFT: Rotate left 30 degrees
- TURN_RIGHT: Rotate right 30 degrees  
- MOVE_FORWARD: Increase speed to 1.0 m/s
- REDUCE_SPEED: Reduce speed to 0.3 m/s
- MAINTAIN_COURSE: Continue current trajectory

Respond in this exact format:
REASONING: [Your analysis of the situation in one sentence]
ACTION: [One of the five actions above]`
                    }]
                  }]
                })
              });

              if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
              }

              const data = await response.json();
              const fullText = data.candidates[0].content.parts[0].text;
              
              // Parse the response
              const reasoningMatch = fullText.match(/REASONING:\s*(.+?)(?=ACTION:|$)/s);
              const actionMatch = fullText.match(/ACTION:\s*(\w+)/);
              
              const reasoning = reasoningMatch ? reasoningMatch[1].trim() : 'Analysis completed';
              const action = actionMatch ? actionMatch[1].trim() : 'MAINTAIN_COURSE';
              
              setAgentThinking(reasoning);
              addLog(`Gemini reasoning: ${reasoning}`, 'info');
              addLog(`Gemini action: ${action}`, 'success');
              
              return action;
            } catch (error) {
              addLog(`API Error: ${error.message}`, 'error');
              
              if (error.message.includes('Failed to fetch')) {
                addLog('üí° Tip: CORS error - Consider using backend proxy server', 'warning');
              }
              
              // Fallback to rule-based logic
              let reasoning = '';
              let action = '';
              
              if (processedData.obstacleDistance !== null && processedData.obstacleDistance < 30) {
                reasoning = 'Obstacle detected at close range. Risk of collision high. (Fallback logic)';
                action = processedData.rotation > 0 ? 'TURN_RIGHT' : 'TURN_LEFT';
              } else if (Math.abs(processedData.rotation) > 5) {
                reasoning = 'High rotation detected. Stabilizing orientation. (Fallback logic)';
                action = 'REDUCE_SPEED';
              } else if (processedData.velocity < 0.5) {
                reasoning = 'Low velocity detected. Safe to increase speed. (Fallback logic)';
                action = 'MOVE_FORWARD';
              } else {
                reasoning = 'All systems normal. Continuing current trajectory. (Fallback logic)';
                action = 'MAINTAIN_COURSE';
              }
              
              setAgentThinking(reasoning);
              addLog(`Fallback reasoning: ${reasoning}`, 'warning');
              return action;
            }
          };

          const executeDecision = (action) => {
            setDecision(action);
            const commands = {
              'TURN_LEFT': '‚Ü∫ Rotating left 30¬∞',
              'TURN_RIGHT': '‚Üª Rotating right 30¬∞',
              'MOVE_FORWARD': '‚Üë Increasing speed to 1.0 m/s',
              'REDUCE_SPEED': '‚Üì Reducing speed to 0.3 m/s',
              'MAINTAIN_COURSE': '‚Üí Maintaining current course'
            };
            addLog(`Decision: ${commands[action]}`, 'warning');
          };

          const runSimulationStep = async () => {
            switch(currentStep) {
              case 0:
                simulateSensorData();
                break;
              case 1:
                if (sensorData) preprocessData(sensorData);
                break;
              case 2:
                if (processedData) engineerContext(processedData);
                break;
              case 3:
                if (processedData) {
                  const action = await agentReasoning(engineerContext(processedData));
                  window.lastAction = action;
                }
                break;
              case 4:
                if (window.lastAction) {
                  executeDecision(window.lastAction);
                }
                break;
              case 5:
                addLog('Cycle complete - metrics logged', 'success');
                break;
            }
            
            setCurrentStep(prev => (prev + 1) % steps.length);
          };

          useEffect(() => {
            if (isRunning) {
              intervalRef.current = setInterval(runSimulationStep, 2000);
            } else {
              if (intervalRef.current) clearInterval(intervalRef.current);
            }
            return () => {
              if (intervalRef.current) clearInterval(intervalRef.current);
            };
          }, [isRunning, currentStep, sensorData, processedData, agentThinking]);

          const reset = () => {
            setIsRunning(false);
            setCurrentStep(0);
            setSensorData({
              imu: { accelX: 0, accelY: 0, gyroZ: 0 },
              camera: { obstacleDetected: false, distance: 0 },
              position: { x: 50, y: 50, angle: 0 }
            });
            setProcessedData(null);
            setAgentThinking('');
            setDecision('');
            setLogs([]);
          };

          return (
            <div className="min-h-screen bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-6">
              <div className="max-w-7xl mx-auto">
                <div className="bg-slate-800 rounded-lg shadow-2xl p-6 mb-6 border border-slate-700">
                  <h1 className="text-3xl font-bold text-blue-400 mb-2">AMR Edge Device Simulation</h1>
                  <p className="text-slate-300">Autonomous Mobile Robot with Google Gemini AI Agent</p>
                </div>

                {showApiInput && (
                  <div className="bg-yellow-900 border border-yellow-700 rounded-lg shadow-xl p-6 mb-6">
                    <h2 className="text-xl font-semibold text-yellow-200 mb-4">‚öôÔ∏è Configure Google Gemini API</h2>
                    <p className="text-yellow-100 mb-4 text-sm">
                      Enter your Google Gemini API key to enable AI-powered decision making.
                      <a href="https://aistudio.google.com/app/apikey" target="_blank" rel="noopener noreferrer" className="underline ml-2">Get API Key ‚Üí</a>
                    </p>
                    <div className="flex gap-3">
                      <input
                        type="password"
                        placeholder="Enter your Gemini API key..."
                        value={apiKey}
                        onChange={(e) => setApiKey(e.target.value)}
                        className="flex-1 px-4 py-2 bg-slate-800 border border-slate-600 rounded text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-blue-500"
                      />
                      <button
                        onClick={() => {
                          if (apiKey.trim()) {
                            apiKeyRef.current = apiKey.trim();
                            setShowApiInput(false);
                            addLog('Google Gemini API configured successfully', 'success');
                          }
                        }}
                        className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-semibold transition-all"
                      >
                        Save
                      </button>
                    </div>
                    <p className="text-yellow-200 text-xs mt-3">
                      üí° Note: Direct API calls may fail due to CORS. Consider using a backend proxy for production.
                    </p>
                  </div>
                )}

                {!showApiInput && (
                  <div className="bg-green-900 border border-green-700 rounded-lg shadow-xl p-4 mb-6 flex items-center justify-between">
                    <p className="text-green-200">‚úì Google Gemini API configured</p>
                    <button
                      onClick={() => setShowApiInput(true)}
                      className="text-green-300 hover:text-green-100 text-sm underline"
                    >
                      Change API Key
                    </button>
                  </div>
                )}

                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-6">
                  <div className="bg-slate-800 rounded-lg shadow-xl p-6 border border-slate-700">
                    <div className="flex items-center gap-2 mb-4">
                      <Activity size={24} className="text-green-400" />
                      <h2 className="text-xl font-semibold text-slate-100">Pipeline Status</h2>
                    </div>
                    <div className="space-y-3">
                      {steps.map((step, idx) => (
                        <div key={idx} className={`p-3 rounded-lg transition-all ${
                          idx === currentStep 
                            ? 'bg-blue-600 text-white shadow-lg scale-105' 
                            : idx < currentStep 
                            ? 'bg-slate-700 text-slate-300' 
                            : 'bg-slate-900 text-slate-500'
                        }`}>
                          <div className="flex items-center gap-3">
                            <div className={`w-8 h-8 rounded-full flex items-center justify-center ${
                              idx === currentStep ? 'bg-blue-700' : idx < currentStep ? 'bg-slate-600' : 'bg-slate-800'
                            }`}>
                              {idx + 1}
                            </div>
                            <span className="font-medium">{step}</span>
                          </div>
                        </div>
                      ))}
                    </div>
                  </div>

                  <div className="space-y-6">
                    <div className="bg-slate-800 rounded-lg shadow-xl p-6 border border-slate-700">
                      <div className="flex items-center gap-2 mb-4">
                        <Compass size={24} className="text-blue-400" />
                        <h2 className="text-xl font-semibold text-slate-100">Sensor Data</h2>
                      </div>
                      <div className="space-y-2 text-sm">
                        <div className="flex justify-between text-slate-300">
                          <span>Accel X:</span>
                          <span className="font-mono">{sensorData.imu.accelX.toFixed(3)} m/s¬≤</span>
                        </div>
                        <div className="flex justify-between text-slate-300">
                          <span>Accel Y:</span>
                          <span className="font-mono">{sensorData.imu.accelY.toFixed(3)} m/s¬≤</span>
                        </div>
                        <div className="flex justify-between text-slate-300">
                          <span>Gyro Z:</span>
                          <span className="font-mono">{sensorData.imu.gyroZ.toFixed(3)} deg/s</span>
                        </div>
                        <div className="flex justify-between text-slate-300">
                          <span>Obstacle:</span>
                          <span className={sensorData.camera.obstacleDetected ? 'text-red-400' : 'text-green-400'}>
                            {sensorData.camera.obstacleDetected ? `${sensorData.camera.distance.toFixed(1)}m` : 'Clear'}
                          </span>
                        </div>
                      </div>
                    </div>

                    <div className="bg-slate-800 rounded-lg shadow-xl p-6 border border-slate-700">
                      <div className="flex items-center gap-2 mb-4">
                        <Camera size={24} className="text-purple-400" />
                        <h2 className="text-xl font-semibold text-slate-100">Agent Output</h2>
                      </div>
                      <div className="space-y-3">
                        <div>
                          <p className="text-slate-400 text-sm mb-1">Reasoning:</p>
                          <p className="text-slate-200 text-sm">{agentThinking || 'Waiting for input...'}</p>
                        </div>
                        <div>
                          <p className="text-slate-400 text-sm mb-1">Decision:</p>
                          <p className="text-yellow-400 font-semibold">{decision || 'N/A'}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div className="bg-slate-800 rounded-lg shadow-xl p-6 border border-slate-700 mb-6">
                  <h2 className="text-xl font-semibold text-slate-100 mb-4">System Logs</h2>
                  <div className="bg-slate-900 rounded p-4 h-48 overflow-y-auto font-mono text-sm">
                    {logs.length === 0 ? (
                      <p className="text-slate-500">No logs yet. Start the simulation.</p>
                    ) : (
                      logs.map((log, idx) => (
                        <div key={idx} className={log.color}>
                          <span className="text-slate-500">[{log.time}]</span> {log.message}
                        </div>
                      ))
                    )}
                  </div>
                </div>

                <div className="flex gap-4 justify-center">
                  <button
                    onClick={() => setIsRunning(!isRunning)}
                    className={`flex items-center gap-2 px-6 py-3 rounded-lg font-semibold transition-all ${
                      isRunning 
                        ? 'bg-red-600 hover:bg-red-700 text-white' 
                        : 'bg-green-600 hover:bg-green-700 text-white'
                    }`}
                  >
                    {isRunning ? <><Pause size={20} /> Pause</> : <><Play size={20} /> Start</>}
                  </button>
                  <button
                    onClick={reset}
                    className="flex items-center gap-2 px-6 py-3 bg-slate-700 hover:bg-slate-600 text-white rounded-lg font-semibold transition-all"
                  >
                    <RotateCcw size={20} /> Reset
                  </button>
                </div>
              </div>
            </div>
          );
        };

        ReactDOM.render(<AMRSimulation />, document.getElementById('root'));
    </script>
</body>
</html>
